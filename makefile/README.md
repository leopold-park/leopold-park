# Makefile
## 빌드 과정
- 빌드(build)
    - 소스코드를 실행할 수 있는 바이너리로 변환하는 과정
    - 컴파일(Compile): 소스코드를 기계어로 번역하여 목적파일(object) 생성
      - 목적파일(Object): 기계어로 번역된 파일
    - 링킹(Linking): 목적파읽들과 라이브러리(Library)를 하나로 묶어 실행 파일로 변환
      - 라이브러리(Library): 주로사용하는 소스코드들을 함수의 형태로 미리 작성하여 프로그래머가 원할 때 빠르게 사용할 수 있게 가공된 형탸
        - 주로 SDK(Software Development Kit)의 형태로 라이브러리(Library)파일과 헤더(Header)파일이 묶여 같이 배도됨
      - 라이브러리(Library) 파일: 헤더(Header)파일에 선언되어있는 함수들이 실제 구현되어 미리 컴파일되어있는 파일
      - 헤더(Header)파일 : 함수의 형태를 알기위해 함수의 원형이 선언되어 저장되어있는 파일
      - /usr/lib ,usr/lib/X86_64-linux-gnu 위치에 저장
- 호스트(Host)
    - 진행되는 환경
- 타겟(Target)
    - 빌드를 통해 생성된 실제 바이너리 파일이 동작할 환경
    - 타겟의 환경에 따라 각각 다른 바이너리 파일이 요구됨
- 툴체인
    - 원하는 타겟에 맞춰 빌드를 해주는 개발 도구들의 모음
    - 컴파일러(compiler) : 소스코드를 기계어로 번역
      - 기계어로 번역된 파일을 목적파일(object)이라고 부름
    - 헤더(header) 및 라이브러리(Library) : include로 사용하는 기본 함수 모음 
      - 주로 SDK(Software Development Kit)의 형태로 배포됨
    - 링커(Linker): 여러 목적파일과 라이브러리를 모아 하나의 바이너리로 결합
  
  목적파일 생성과 링킹 예시
```bash
sudo apt-get install -y build-essential #build-essential : 데비안(Debian)계열 리눅스의 개발에 필요헌 라이브러리및 도구들이 포함된 패키지
                                        #리눅스에서 주로 사용되는 컴파일러인 GCC가 포함
                                        #GCC안에 LD라는 링커가 포함되어있음
gcc -c *.c                              # 현재 디렉토리내 모든 c파일을 컴파일하여 목적파일 생성
                                        # -c : 컴파일 하여 목적파일 생성
                                        # *.c : 현재 디렉토리 내 모든 C 파일 선택
ld *.o                                  # 현 디렉토리 내 모든 목적파일들과 라이브러리들을 링킹
                                        # 실제 수행시 Undefined reference to '???'와 Cannot find entry symbol _start 두가지 에러로 수행되지 않음
                                        # Undefined reference to '???' : 라이브러리가 지정되지않아 사용된 함수의 정의를 찾을수 없어 발생된 문제
                                        # Cannot find entry symbol _start : C Runtime 목적파일을 포함하지 않아 각종 환경 변수와 파라미터 초기화 및 메인(main)함수 호출이 불가능해 발생된 문제  
```
-  라이브러리 지정
   - 기본적인 함수들도 라이브러리를 지정해 링커에게 함수의 위치를 알려주어야 함
   - ld 또는 gcc에서 라이브러지 사용시 -ㅣ 뒤에 라이브러리명에서 lib를 떼고 붙여 라이브러리 지정 
- C Runtime(CRT) 목적파일:C언어의 main에 이르기까지의 초기화 수행 및 메인 함수 호출
    - 운영체체마다 환경변수나 파라미터를 다루는 방식과 초기화 방식이 다름
    - 운영체제마다 자신의 환경에 맞는 CRT 목적파일이 초기화 과정을 수행후 메인함수를 호출
    - 이로인해 운영체제가 달라도 같은 형태의 main함수 사용 가능
```bash
ld *.o /usr/lib/X86_64-linux-gnu/crt1.o -lm -lc # crt목적파일을 /usr/lib/X86_64-linux-gnu/crt1.o로 지정하여 libc와 libm 라이브러리를 포함하여 링킹
                                                # X86_64-linux-gnu : inter X86과 AMD의 amd64 CPU 아키텍처의 리눅스 라이브러리 등이 저장되어있는 디렉토리
                                                # arm기반 CPU 아키텍처 시스템에서는 aarch64-linux-gnu 디렉토리에 저장
                                                # 실행파일의 이름을 지정해주지 않아 a.out라는 이름으로 실행파일 생성
                                                # 실행파일 이름은 -o 옵션을 이용해 지정 가능
./a.out                                         # 현 디렉토리 내의 a.out 파일 실행
                                                # bash: ./a.out: No such file or directory 에러 발생
                                                # a.out 파일이 참조하는 다른 파일을 찾을 수 없어 발생되는 문제
```

> ldd : 의존성(Dependency)이 있는 라이브러리를 검색
>>의존성(Dependency) : 특정 프로그램이 실행하기 위해 반드시 필요한 라이브러리 또는 파일이 존재하는 경우
>>a가 b에 의존성이 있다. -> a가 수행되기 위해서는 반드시 b가 필요하다.

## 동적(Dynamic)라이브러리와 정적(Static)라이브러리
- 동적(Dynamic)라이브러리 : 빌드할 때 결정되지 않고, 실행중간에 필요시 로드(load)하는 라이브러리
- 정적(Static)라이브러리 : 필요시 라이브러리를 로드(load)하지 않고, 빌드시 사전에 미리 로드(load)하는 라이브러리
- 로드(load) : 파일을 메모리(Memory)에 복사하여 CPU에서 접근이 가능하도록 하는 작업 
- LD 라이브러리
  - 동적(Dynamically)으로 필요한 라이브러리를 로드(load)하는 라이브러리 Dynamic Linker라고도 부림
ld 동적 라이브러리 추가 예제
```bash
ld *.o /usr/lib/x86_64-linux-gnu/crt1.o -lm -lc -dynamic-linker=/lib64/ld-linux-X86-64.so.2
```
> gcc를 이용할 경우 내부 ld를 이용하여 컴파일부터 링킹까지 진행 가능함
>> gcc에서는 libc, crt, ld 라이브러리를 자동으로 추가시켜줌
>> -v 옵션을 이용해 어떤동작을 하는지 자세하게 확인 가능

## 점진적 빌드(Incremental build)
- 컴파일 과정은 복잡하고 시간이 많이 걸림
  - 코드해석 -> 함수 참조 해석 -> 최적화 -> 목적파일로 변환
    - 최적화 : 불필요한 함수나 코드를 줄여 실행속도나 필요한 메모리 양을 개선 하는 것
- 점진적 빌드(Increment build): 컴파일시 모든 파일을 컴파일 하지 않고 변경된 파일과 그파일을 참조하는 파일만 컴파일 하는 방식
  - 파일 수가 많고 프로그램이 클 경우 수정된 파일만 컴파일하고 기존 목적파일과 링킹하여 빌드에 걸리는 시간을 줄일 수 있음
  - 직접 링킹을 해야하기때문에 빌드를 수행하는 사람이 프로그램 전체의 의존성을 알고있어야 함
## 빌드시스템(build system)
- 개발자가 의존성을 파악하지 않아도 점진적 빌드가 가능하게 도움
  - 수정한 부분과 그에 대한 의존성이 있는 부분을 분석
  - 복잡한 컴파일 및 링킹 명령어를 손쉽게 다룰 수 있게 도움
- 종류
  - Makefile: 가장 만ㄹ이 사용되는 빌드 시스템
    - 명령어 사용이 용이함
    - 리눅스 커널과 안드로이드 일부에서 사용중
  - CMake: CMakeLists.txt 파일로 작성
    - MAkefile로 번역되어 사용됨
    - 삼성의 타이젠에서 사용
  - Ninja: 속도 측면의 향상을 위한 빌드 시스템
    - Qemu, 안드로이드에서 사용
## Makefile의 구성
